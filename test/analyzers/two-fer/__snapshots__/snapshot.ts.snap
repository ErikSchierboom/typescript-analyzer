// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/1's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/10's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/11's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/12's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/13's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/14's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/15's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(s?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(s?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/16's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/17's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/18's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/19's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/20's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/22's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(person?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(person?: string)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/23's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/24's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(id?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(id?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/25's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/26's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/27's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(X?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(X?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/28's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/29's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/30's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/33's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/34's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/100's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/101's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/103's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/104's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/105's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/106's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(x?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(x?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/108's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/109's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/110's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/111's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/113's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/114's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/115's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/117's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/118's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/119's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/122's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/123's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/124's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/125's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/126's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/127's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/128's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(person?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(person?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/129's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/130's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/131's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(person?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(person?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/134's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/135's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/136's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/138's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/139's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/140's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/141's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/143's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/145's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/146's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/147's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/149's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/152's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/154's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/155's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/156's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/158's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/159's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/160's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/161's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/162's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/163's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/164's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/165's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/166's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/168's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/171's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(message?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(message?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/172's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/173's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(x?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(x?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/174's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/175's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/176's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/178's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/179's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/181's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/182's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/183's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/184's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/185's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/187's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/188's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/189's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/190's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/192's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/194's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/195's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/197's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/199's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/200's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/201's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/202's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/203's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/204's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(text?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(text?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/205's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/206's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/207's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/208's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/209's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/210's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/211's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/212's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/213's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/214's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(input?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(input?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/215's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/217's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/219's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/220's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/224's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/226's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/227's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(addresse?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(addresse?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/228's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/233's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/234's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/235's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(str?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(str?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/236's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/237's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/238's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/239's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/240's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/241's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/242's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/243's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/246's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/248's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/249's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/250's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/252's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/253's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/255's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/256's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/257's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(msg?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(msg?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/260's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/261's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/262's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/263's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/264's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/266's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/267's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/268's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/269's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/270's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/271's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/272's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/273's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/274's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/275's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/276's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/277's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/278's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/280's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/281's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/282's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/284's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/285's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/287's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/288's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/289's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/290's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/291's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/292's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/293's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/295's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/296's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/297's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/300's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/301's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/303's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/307's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/309's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/310's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/311's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/312's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/314's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/315's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/316's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/317's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/318's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/319's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/322's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/323's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/326's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/328's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/330's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/332's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/333's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/334's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/336's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/338's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(firstPerson?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(firstPerson?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/339's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/341's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to approve matches two-fer/342's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.export_inline",
      "message": "Did you know that you can export functions, classes and constants directly
inline?",
      "template": "Did you know that you can export functions, classes and constants directly
inline?",
      "variables": Object {},
    },
  ],
  "status": "approve",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/0's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/2's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/3's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/5's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/21's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/32's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/40's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/41's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(x?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(x?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/42's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/45's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_required_parameter",
      "message": "The parameter \`name\` is called with and without a value in
the tests, but you have not marked it as optional, which means that the tests
won't pass. You can fix this by marking it explicitly as optional:

\`\`\`typescript
  function(name?: string\\") {
    //
  }
\`\`\`

Or by assigning a default value:

\`\`\`typescript
  function(name: string = <default>) {
    //
  }
\`\`\`",
      "template": "The parameter \`%{parameter.name}\` is called with and without a value in
the tests, but you have not marked it as optional, which means that the tests
won't pass. You can fix this by marking it explicitly as optional:

\`\`\`typescript
  function(%{parameter.name}?: %{parameter.type}\\") {
    //
  }
\`\`\`

Or by assigning a default value:

\`\`\`typescript
  function(%{parameter.name}: %{parameter.type} = <default>) {
    //
  }
\`\`\`",
      "variables": Object {
        "parameter.name": "name",
        "parameter.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/48's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/53's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/60's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/102's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/112's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/116's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string | null): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string | null)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/120's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/121's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/132's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/133's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/137's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(param?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(param?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/142's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(aName?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(aName?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of aName to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "aName",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/150's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/151's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/153's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/157's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/167's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/169's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/177's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(message?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(message?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/186's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/191's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/193's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/196's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/198's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/216's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/218's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/221's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/222's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/223's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/225's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/230's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/231's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/232's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/244's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_required_parameter",
      "message": "The parameter \`name\` is called with and without a value in
the tests, but you have not marked it as optional, which means that the tests
won't pass. You can fix this by marking it explicitly as optional:

\`\`\`typescript
  function(name?: string\\") {
    //
  }
\`\`\`

Or by assigning a default value:

\`\`\`typescript
  function(name: string = <default>) {
    //
  }
\`\`\`",
      "template": "The parameter \`%{parameter.name}\` is called with and without a value in
the tests, but you have not marked it as optional, which means that the tests
won't pass. You can fix this by marking it explicitly as optional:

\`\`\`typescript
  function(%{parameter.name}?: %{parameter.type}\\") {
    //
  }
\`\`\`

Or by assigning a default value:

\`\`\`typescript
  function(%{parameter.name}: %{parameter.type} = <default>) {
    //
  }
\`\`\`",
      "variables": Object {
        "parameter.name": "name",
        "parameter.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/245's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/247's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/251's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/254's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(input?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(input?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of input to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "input",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/258's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/259's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string | undefined): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string | undefined)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/265's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(msg?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(msg?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of msg to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "msg",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/283's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/298's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/299's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/302's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/304's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/305's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/306's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: any): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: any)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/308's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/313's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/321's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/324's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/325's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/327's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/329's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/331's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/335's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/337's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/340's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/344's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/354's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/355's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_strict_equality",
      "message": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "template": "In _JavaScript_, always prefer [strict (identity and non-identity) equality](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity)
such as \`===\` and \`!==\` over the forms that use implicit type coercion,
such as [\`==\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality)
and [\`!=\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality),
unless you explicitly want to coerce the type of one of the two operands.

The same is true for typescript, even though _TypeScript_ tracks the
types, as there are many cases where TypeScript won't be able to guard against
this implicit type coercion.",
      "variables": Object {},
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/365's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/367's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/368's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/370's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/371's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/375's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/376's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(towhom?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(towhom?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/391's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/403's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(who?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(who?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of who to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "who",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/405's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/410's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/415's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/416's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(_input?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(_input?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of _input to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "_input",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/422's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/423's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/427's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/433's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/434's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/436's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_explicity_default_value",
      "message": "Instead of relying on name being \\"undefined\\" when
no value is passed in, you could set the default value of 'name' to
'you'.",
      "template": "Instead of relying on %{maybe-undefined-expression} being \\"undefined\\" when
no value is passed in, you could set the default value of '%{parameter}' to
'you'.",
      "variables": Object {
        "maybe-undefined-expression": "name",
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/438's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/439's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/440's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of name to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "name",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/444's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/454's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/470's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescrypt.general.prefer_templated_strings",
      "message": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "template": "You're manually building a string using string concatenation. You can use a
[templated string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
instead and interpolate dynamic values:

\`\`\`typescript
\\"Hello there \${firstName}, I will give you \${calculateInventory()} apples.\\"
\`\`\`",
      "variables": Object {},
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/481's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/484's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.unexpected_boxed_type",
      "message": "You're using a boxed type \`String\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`string' instead.",
      "template": "You're using a boxed type \`%{boxed.type}\`. In TypeScript, the types
\`Object\`, \`Number\`, \`Boolean\` and \`String\` are types which refer to
non-primitive boxed objects that are almost never used appropriately in
TypeScript or JavaScript code.

Use \`%{literal.type}' instead.",
      "variables": Object {
        "boxed.type": "String",
        "literal.type": "string",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to disapprove matches two-fer/497's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(person?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(person?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.optimise_default_value",
      "message": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of person to
'you' to avoid this conditional.",
      "template": "You currently use a conditional to branch in case there is no value passed
into twoFer, but instead you could set the default value of %{parameter} to
'you' to avoid this conditional.",
      "variables": Object {
        "parameter": "person",
      },
    },
  ],
  "status": "disapprove",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/7's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/31's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/54's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name1?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name1?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "variables": Object {},
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/107's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/144's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/148's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(you?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(you?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "variables": Object {},
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/180's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(input?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(input?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/229's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(message?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(message?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/279's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/320's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/358's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/366's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/383's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name1?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name1?: string)",
      },
    },
    CommentImpl {
      "externalTemplate": "typescript.two-fer.redirect_incorrect_string_template",
      "message": "The string template looks incorrect. Expected a template with 3 components.",
      "template": "The string template looks incorrect. Expected a template with 3 components.",
      "variables": Object {},
    },
  ],
  "status": "refer_to_mentor",
}
`;

exports[`When running analysis on two-fer fixtures and expecting it to refer to mentor matches two-fer/442's output: output 1`] = `
AnalyzerOutput {
  "comments": Array [
    CommentImpl {
      "externalTemplate": "typescript.general.prefer_explicit_return_type",
      "message": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  twoFer(name?: string): <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "template": "TypeScript is really good at type inference and will assign a return type to
your functions. In order to guard against accidental changes, always define
the return type for public API, such as functions you export:

\`\`\`typescript
  %{signature}: <return-type> {}
\`\`\`

Now, if you accidentally change your function to return a different type,
compilation fails and you have successfully guarded against a source of bugs.",
      "variables": Object {
        "signature": "twoFer(name?: string)",
      },
    },
  ],
  "status": "refer_to_mentor",
}
`;
